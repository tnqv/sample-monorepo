# ===========================================
# Release Pipeline - sampleworker
# ===========================================
# Releases sampleworker service: staging â†’ approval â†’ prod
# Uses Jsonnet to render task definitions from task-definitions/

name: "Release: sampleworker"

on:
  push:
    branches:
      - release
    paths:
      - 'cmd/sampleworker/**'
      - 'internal/**'
      - 'go.mod'
      - 'go.sum'
      - 'task-definitions/sampleworker.jsonnet'
      - 'task-definitions/lib/**'
  workflow_dispatch:
    inputs:
      skip_staging:
        description: 'Skip staging (deploy directly to prod)'
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: email-platform
  SERVICE_NAME: sampleworker

concurrency:
  group: release-sampleworker
  cancel-in-progress: false

jobs:
  # ===========================================
  # Build Image
  # ===========================================
  build:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}

    steps:
      - uses: actions/checkout@v4

      - name: Generate image tag
        id: meta
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${{ env.SERVICE_NAME }}-${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      # Dummy steps for testing - uncomment below for real deployment
      - name: Build Image (dummy)
        run: |
          echo "Building image: ${{ steps.meta.outputs.image_tag }}"
          echo "Would build and push to ECR"

      # Real implementation (uncomment when ready):
      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
      #     aws-region: ${{ env.AWS_REGION }}
      #
      # - name: Login to Amazon ECR
      #   id: login-ecr
      #   uses: aws-actions/amazon-ecr-login@v2
      #
      # - name: Build and push image
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: .
      #     file: cmd/${{ env.SERVICE_NAME }}/Dockerfile
      #     push: true
      #     tags: |
      #       ${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}/staging/${{ env.SERVICE_NAME }}:${{ steps.meta.outputs.image_tag }}
      #       ${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}/prod/${{ env.SERVICE_NAME }}:${{ steps.meta.outputs.image_tag }}

      - name: Build summary
        run: |
          echo "## ðŸ”¨ Build Complete - ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ steps.meta.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Deploy to Staging
  # ===========================================
  deploy-staging:
    needs: build
    if: ${{ !inputs.skip_staging }}
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Install Jsonnet
        run: |
          sudo apt-get update && sudo apt-get install -y jsonnet

      - name: Render task definition with Jsonnet
        id: render
        run: |
          # These would come from Terraform outputs or AWS SSM in real deployment
          ECR_REPO="123456789.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.PROJECT_NAME }}/staging/${{ env.SERVICE_NAME }}"
          EXECUTION_ROLE_ARN="arn:aws:iam::123456789:role/${{ env.PROJECT_NAME }}-staging-ecs-execution-role"
          TASK_ROLE_ARN="arn:aws:iam::123456789:role/${{ env.PROJECT_NAME }}-staging-ecs-task-role"
          SQS_QUEUE_URL="https://sqs.${{ env.AWS_REGION }}.amazonaws.com/123456789/${{ env.PROJECT_NAME }}-staging-tasks"
          SQS_DLQ_URL="https://sqs.${{ env.AWS_REGION }}.amazonaws.com/123456789/${{ env.PROJECT_NAME }}-staging-tasks-dlq"
          SECRET_ARN="arn:aws:secretsmanager:${{ env.AWS_REGION }}:123456789:secret:${{ env.PROJECT_NAME }}/staging/worker-secret"
          
          cd task-definitions
          jsonnet \
            --ext-str IMAGE_TAG="${{ needs.build.outputs.image_tag }}" \
            --ext-str ENVIRONMENT="staging" \
            --ext-str AWS_REGION="${{ env.AWS_REGION }}" \
            --ext-str ECR_REPOSITORY="$ECR_REPO" \
            --ext-str EXECUTION_ROLE_ARN="$EXECUTION_ROLE_ARN" \
            --ext-str TASK_ROLE_ARN="$TASK_ROLE_ARN" \
            --ext-str SQS_QUEUE_URL="$SQS_QUEUE_URL" \
            --ext-str SQS_DLQ_URL="$SQS_DLQ_URL" \
            --ext-str SECRET_ARN="$SECRET_ARN" \
            ${{ env.SERVICE_NAME }}.jsonnet > ../task-definition.json
          cd ..
          
          echo "Generated task definition:"
          cat task-definition.json

      # Dummy steps for testing
      - name: Deploy to ECS Staging (dummy)
        run: |
          echo "Would deploy to staging with task definition:"
          cat task-definition.json

      # Real implementation (uncomment when ready):
      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
      #     aws-region: ${{ env.AWS_REGION }}
      #
      # - name: Register task definition
      #   id: task-def
      #   run: |
      #     TASK_DEF_ARN=$(aws ecs register-task-definition \
      #       --cli-input-json file://task-definition.json \
      #       --query 'taskDefinition.taskDefinitionArn' \
      #       --output text)
      #     echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
      #
      # - name: Update ECS service
      #   run: |
      #     aws ecs update-service \
      #       --cluster ${{ env.PROJECT_NAME }}-staging \
      #       --service ${{ env.PROJECT_NAME }}-staging-${{ env.SERVICE_NAME }} \
      #       --task-definition ${{ steps.task-def.outputs.task_def_arn }} \
      #       --force-new-deployment
      #
      # - name: Wait for service stability
      #   run: |
      #     aws ecs wait services-stable \
      #       --cluster ${{ env.PROJECT_NAME }}-staging \
      #       --services ${{ env.PROJECT_NAME }}-staging-${{ env.SERVICE_NAME }}

      - name: Staging summary
        run: |
          echo "## ðŸŸ¡ Staging Deployed - ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Staging deployment successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â³ **Waiting for production approval...**" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Deploy to Production (Approval Required)
  # ===========================================
  deploy-production:
    needs: [build, deploy-staging]
    if: always() && needs.build.result == 'success' && (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped')
    runs-on: ubuntu-latest
    environment: prod
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Install Jsonnet
        run: |
          sudo apt-get update && sudo apt-get install -y jsonnet

      - name: Render task definition with Jsonnet
        id: render
        run: |
          # These would come from Terraform outputs or AWS SSM in real deployment
          ECR_REPO="123456789.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.SERVICE_NAME }}"
          EXECUTION_ROLE_ARN="arn:aws:iam::123456789:role/${{ env.PROJECT_NAME }}-dummy-ecs-execution-role"
          TASK_ROLE_ARN="arn:aws:iam::123456789:role/${{ env.PROJECT_NAME }}-dummy-ecs-task-role"
          SQS_QUEUE_URL="dummy"
          SQS_DLQ_URL="dummy"
          SECRET_ARN="dummy-secret-arn"
          
          cd task-definitions
          jsonnet \
            --ext-str IMAGE_TAG="${{ needs.build.outputs.image_tag }}" \
            --ext-str ENVIRONMENT="prod" \
            --ext-str AWS_REGION="${{ env.AWS_REGION }}" \
            --ext-str ECR_REPOSITORY="$ECR_REPO" \
            --ext-str EXECUTION_ROLE_ARN="$EXECUTION_ROLE_ARN" \
            --ext-str TASK_ROLE_ARN="$TASK_ROLE_ARN" \
            --ext-str SQS_QUEUE_URL="$SQS_QUEUE_URL" \
            --ext-str SQS_DLQ_URL="$SQS_DLQ_URL" \
            --ext-str SECRET_ARN="$SECRET_ARN" \
            ${{ env.SERVICE_NAME }}.jsonnet > ../task-definition.json
          cd ..
          
          echo "Generated task definition:"
          cat task-definition.json

      # Dummy steps for testing
      - name: Deploy to ECS Production (dummy)
        run: |
          echo "Deploy to production with task definition:"
          cat task-definition.json

      # Real implementation (uncomment when ready):
      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
      #     aws-region: ${{ env.AWS_REGION }}
      #
      # - name: Register task definition
      #   id: task-def
      #   run: |
      #     TASK_DEF_ARN=$(aws ecs register-task-definition \
      #       --cli-input-json file://task-definition.json \
      #       --query 'taskDefinition.taskDefinitionArn' \
      #       --output text)
      #     echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
      #
      # - name: Update ECS service
      #   run: |
      #     aws ecs update-service \
      #       --cluster ${{ env.PROJECT_NAME }}-prod \
      #       --service ${{ env.PROJECT_NAME }}-prod-${{ env.SERVICE_NAME }} \
      #       --task-definition ${{ steps.task-def.outputs.task_def_arn }} \
      #       --force-new-deployment
      #
      # - name: Wait for service stability
      #   run: |
      #     aws ecs wait services-stable \
      #       --cluster ${{ env.PROJECT_NAME }}-prod \
      #       --services ${{ env.PROJECT_NAME }}-prod-${{ env.SERVICE_NAME }}

      - name: Production summary
        run: |
          echo "## ðŸŸ¢ Production Deployed - ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Service | **${{ env.SERVICE_NAME }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ needs.build.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Approved by | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY

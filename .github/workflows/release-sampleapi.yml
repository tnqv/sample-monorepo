# ===========================================
# Release Pipeline - sampleapi
# ===========================================
# Releases sampleapi service: staging â†’ approval â†’ prod
# Uses LocalStack for testing ECS deployments

name: "Release: sampleapi"

on:
  push:
    branches:
      - release
    paths:
      - 'cmd/sampleapi/**'
      - 'internal/**'
      - 'go.mod'
      - 'go.sum'
      - 'task-definitions/sampleapi.jsonnet'
      - 'task-definitions/lib/**'
  workflow_dispatch:
    inputs:
      skip_staging:
        description: 'Skip staging (deploy directly to prod)'
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: email-platform
  SERVICE_NAME: sampleapi
  # LocalStack configuration
  AWS_ENDPOINT_URL: http://localhost:4566
  AWS_ACCESS_KEY_ID: test
  AWS_SECRET_ACCESS_KEY: test

concurrency:
  group: release-sampleapi
  cancel-in-progress: false

jobs:
  # ===========================================
  # Build Image & Push to LocalStack ECR
  # ===========================================
  build:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      ecr_image: ${{ steps.push.outputs.ecr_image }}

    services:
      localstack:
        image: localstack/localstack-pro:latest
        ports:
          - 4566:4566
        env:
          LOCALSTACK_AUTH_TOKEN: ${{ secrets.LOCALSTACK_AUTH_TOKEN }}
          SERVICES: ecr
          DEBUG: 0
        options: >-
          --health-cmd="curl -f http://localhost:4566/_localstack/health || exit 1"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - uses: actions/checkout@v4

      - name: Generate image tag
        id: meta
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${{ env.SERVICE_NAME }}-${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Install LocalStack CLI
        run: pip install localstack

      - name: Import LocalStack State
        run: |
          # Import pre-provisioned state (includes ECR repositories from Terraform)
          STATE_FILE="terraform/aws/environments/staging/localstack-state.zip"
          if [ -f "$STATE_FILE" ]; then
            echo "Importing LocalStack state from $STATE_FILE"
            localstack state import "$STATE_FILE"
          else
            echo "No state file found, ECR repository may not exist"
          fi
        env:
          LOCALSTACK_AUTH_TOKEN: ${{ secrets.LOCALSTACK_AUTH_TOKEN }}

      - name: Verify ECR Repository
        run: |
          echo "Listing ECR repositories..."
          aws ecr describe-repositories --query 'repositories[].repositoryName' --output table || echo "No repositories found"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host

      - name: Build Docker Image
        run: |
          echo "Building Docker image..."
          docker build \
            -t ${{ env.SERVICE_NAME }}:${{ steps.meta.outputs.image_tag }} \
            -f cmd/${{ env.SERVICE_NAME }}/Dockerfile \
            .
          
          echo "âœ… Image built: ${{ env.SERVICE_NAME }}:${{ steps.meta.outputs.image_tag }}"

      - name: Tag and Push to LocalStack ECR
        id: push
        run: |
          # LocalStack ECR endpoint
          ECR_ENDPOINT="localhost.localstack.cloud:4566"
          ECR_IMAGE="${ECR_ENDPOINT}/${{ env.PROJECT_NAME }}/${{ env.SERVICE_NAME }}:${{ steps.meta.outputs.image_tag }}"
          
          # Tag the image for LocalStack ECR
          docker tag \
            ${{ env.SERVICE_NAME }}:${{ steps.meta.outputs.image_tag }} \
            $ECR_IMAGE
          
          # Push to LocalStack ECR (may fail due to LocalStack limitations, but image is built)
          docker push $ECR_IMAGE 2>/dev/null || echo "âš ï¸ Push to LocalStack ECR skipped (expected limitation)"
          
          echo "ecr_image=$ECR_IMAGE" >> $GITHUB_OUTPUT
          echo "âœ… Image tagged: $ECR_IMAGE"

      - name: Build summary
        run: |
          echo "## ðŸ”¨ Build Complete - ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ steps.meta.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ECR Image | \`${{ steps.push.outputs.ecr_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Dockerfile | \`cmd/${{ env.SERVICE_NAME }}/Dockerfile\` |" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Deploy to Staging
  # ===========================================
  deploy-staging:
    needs: build
    if: ${{ !inputs.skip_staging }}
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      id-token: write
      contents: read

    services:
      localstack:
        image: localstack/localstack-pro:latest
        ports:
          - 4566:4566
        env:
          LOCALSTACK_AUTH_TOKEN: ${{ secrets.LOCALSTACK_AUTH_TOKEN }}
          SERVICES: ec2,ecs,ecr,iam,s3,sqs,secretsmanager,sts,logs,elbv2,application-autoscaling
          # Disable Docker container execution for ECS (mock mode)
          DOCKER_HOST: ""
          DEBUG: 0
        options: >-
          --health-cmd="curl -f http://localhost:4566/_localstack/health || exit 1"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          pip install localstack
          sudo apt-get update && sudo apt-get install -y jsonnet

      - name: Import LocalStack State
        run: |
          STATE_FILE="terraform/aws/environments/staging/localstack-state.zip"
          if [ -f "$STATE_FILE" ]; then
            echo "Importing LocalStack state from $STATE_FILE"
            localstack state import "$STATE_FILE"
          else
            echo "No state file found at $STATE_FILE, starting fresh"
          fi
        env:
          LOCALSTACK_AUTH_TOKEN: ${{ secrets.LOCALSTACK_AUTH_TOKEN }}

      - name: Get Infrastructure Values from LocalStack
        id: infra
        run: |
          # Get ECR repository URL (using LocalStack format)
          ECR_REPO="000000000000.dkr.ecr.${{ env.AWS_REGION }}.localhost.localstack.cloud:4566/${{ env.PROJECT_NAME }}-staging-${{ env.SERVICE_NAME }}"
          
          # Get IAM role ARNs
          EXECUTION_ROLE_ARN=$(aws iam get-role --role-name ${{ env.PROJECT_NAME }}-staging-ecs-execution-role --query 'Role.Arn' --output text 2>/dev/null || echo "arn:aws:iam::000000000000:role/${{ env.PROJECT_NAME }}-staging-ecs-execution-role")
          TASK_ROLE_ARN=$(aws iam get-role --role-name ${{ env.PROJECT_NAME }}-staging-ecs-task-role --query 'Role.Arn' --output text 2>/dev/null || echo "arn:aws:iam::000000000000:role/${{ env.PROJECT_NAME }}-staging-ecs-task-role")
          
          # Get SQS Queue URL
          SQS_QUEUE_URL=$(aws sqs get-queue-url --queue-name ${{ env.PROJECT_NAME }}-staging-tasks --query 'QueueUrl' --output text 2>/dev/null || echo "http://localhost:4566/000000000000/${{ env.PROJECT_NAME }}-staging-tasks")
          
          echo "ecr_repo=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "execution_role_arn=$EXECUTION_ROLE_ARN" >> $GITHUB_OUTPUT
          echo "task_role_arn=$TASK_ROLE_ARN" >> $GITHUB_OUTPUT
          echo "sqs_queue_url=$SQS_QUEUE_URL" >> $GITHUB_OUTPUT
          
          echo "Infrastructure values:"
          echo "  ECR Repository: $ECR_REPO"
          echo "  Execution Role: $EXECUTION_ROLE_ARN"
          echo "  Task Role: $TASK_ROLE_ARN"
          echo "  SQS Queue: $SQS_QUEUE_URL"

      - name: Render Task Definition with Jsonnet
        id: render
        run: |
          cd task-definitions
          jsonnet \
            --ext-str IMAGE_TAG="${{ needs.build.outputs.image_tag }}" \
            --ext-str ENVIRONMENT="staging" \
            --ext-str AWS_REGION="${{ env.AWS_REGION }}" \
            --ext-str ECR_REPOSITORY="${{ steps.infra.outputs.ecr_repo }}" \
            --ext-str EXECUTION_ROLE_ARN="${{ steps.infra.outputs.execution_role_arn }}" \
            --ext-str TASK_ROLE_ARN="${{ steps.infra.outputs.task_role_arn }}" \
            --ext-str SQS_QUEUE_URL="${{ steps.infra.outputs.sqs_queue_url }}" \
            ${{ env.SERVICE_NAME }}.jsonnet > ../task-definition.json
          cd ..
          
          echo "Generated task definition:"
          cat task-definition.json

      - name: Register Task Definition in LocalStack
        id: task-def
        run: |
          echo "Registering task definition in LocalStack..."
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "Registered task definition: $TASK_DEF_ARN"

      - name: Update ECS Service in LocalStack
        continue-on-error: true  # LocalStack may fail without Docker-in-Docker
        run: |
          CLUSTER="${{ env.PROJECT_NAME }}-staging"
          SERVICE="${{ env.PROJECT_NAME }}-staging-${{ env.SERVICE_NAME }}"
          
          echo "Updating ECS service..."
          echo "  Cluster: $CLUSTER"
          echo "  Service: $SERVICE"
          echo "  Task Definition: ${{ steps.task-def.outputs.task_def_arn }}"
          
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "${{ steps.task-def.outputs.task_def_arn }}" \
            --force-new-deployment \
            || echo "Update service failed (expected in mock mode without Docker)"
          
          echo "âœ… Service update command completed"

      - name: Verify Deployment
        continue-on-error: true
        run: |
          CLUSTER="${{ env.PROJECT_NAME }}-staging"
          SERVICE="${{ env.PROJECT_NAME }}-staging-${{ env.SERVICE_NAME }}"
          
          echo "Verifying deployment..."
          aws ecs describe-services \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query 'services[0].{status:status,runningCount:runningCount,desiredCount:desiredCount,taskDefinition:taskDefinition}' \
            || echo "Verify deployment failed (expected in mock mode, not supporting Docker in Docker)"

      - name: Staging summary
        run: |
          echo "## ðŸŸ¡ Staging Deployed - ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Task Definition | \`${{ steps.task-def.outputs.task_def_arn }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ needs.build.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | LocalStack (staging) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â³ **Waiting for production approval...**" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Deploy to Production (Approval Required)
  # ===========================================
  deploy-production:
    needs: [build, deploy-staging]
    if: always() && needs.build.result == 'success' && (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped')
    runs-on: ubuntu-latest
    environment: prod
    permissions:
      id-token: write
      contents: read

    services:
      localstack:
        image: localstack/localstack-pro:latest
        ports:
          - 4566:4566
        env:
          LOCALSTACK_AUTH_TOKEN: ${{ secrets.LOCALSTACK_AUTH_TOKEN }}
          SERVICES: ec2,ecs,ecr,iam,s3,sqs,secretsmanager,sts,logs,elbv2,application-autoscaling
          # Disable Docker container execution for ECS (mock mode)
          DOCKER_HOST: ""
          DEBUG: 0
        options: >-
          --health-cmd="curl -f http://localhost:4566/_localstack/health || exit 1"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          pip install localstack
          sudo apt-get update && sudo apt-get install -y jsonnet

      - name: Import LocalStack State
        run: |
          STATE_FILE="terraform/aws/environments/prod/localstack-state.zip"
          if [ -f "$STATE_FILE" ]; then
            echo "Importing LocalStack state from $STATE_FILE"
            localstack state import "$STATE_FILE"
          else
            echo "No state file found at $STATE_FILE, starting fresh"
          fi
        env:
          LOCALSTACK_AUTH_TOKEN: ${{ secrets.LOCALSTACK_AUTH_TOKEN }}

      - name: Get Infrastructure Values from LocalStack
        id: infra
        run: |
          # Get ECR repository URL (using LocalStack format)
          ECR_REPO="000000000000.dkr.ecr.${{ env.AWS_REGION }}.localhost.localstack.cloud:4566/${{ env.PROJECT_NAME }}-prod-${{ env.SERVICE_NAME }}"
          
          # Get IAM role ARNs
          EXECUTION_ROLE_ARN=$(aws iam get-role --role-name ${{ env.PROJECT_NAME }}-prod-ecs-execution-role --query 'Role.Arn' --output text 2>/dev/null || echo "arn:aws:iam::000000000000:role/${{ env.PROJECT_NAME }}-prod-ecs-execution-role")
          TASK_ROLE_ARN=$(aws iam get-role --role-name ${{ env.PROJECT_NAME }}-prod-ecs-task-role --query 'Role.Arn' --output text 2>/dev/null || echo "arn:aws:iam::000000000000:role/${{ env.PROJECT_NAME }}-prod-ecs-task-role")
          
          # Get SQS Queue URL
          SQS_QUEUE_URL=$(aws sqs get-queue-url --queue-name ${{ env.PROJECT_NAME }}-prod-tasks --query 'QueueUrl' --output text 2>/dev/null || echo "http://localhost:4566/000000000000/${{ env.PROJECT_NAME }}-prod-tasks")
          
          echo "ecr_repo=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "execution_role_arn=$EXECUTION_ROLE_ARN" >> $GITHUB_OUTPUT
          echo "task_role_arn=$TASK_ROLE_ARN" >> $GITHUB_OUTPUT
          echo "sqs_queue_url=$SQS_QUEUE_URL" >> $GITHUB_OUTPUT
          
          echo "Infrastructure values:"
          echo "  ECR Repository: $ECR_REPO"
          echo "  Execution Role: $EXECUTION_ROLE_ARN"
          echo "  Task Role: $TASK_ROLE_ARN"
          echo "  SQS Queue: $SQS_QUEUE_URL"

      - name: Render Task Definition with Jsonnet
        id: render
        run: |
          cd task-definitions
          jsonnet \
            --ext-str IMAGE_TAG="${{ needs.build.outputs.image_tag }}" \
            --ext-str ENVIRONMENT="prod" \
            --ext-str AWS_REGION="${{ env.AWS_REGION }}" \
            --ext-str ECR_REPOSITORY="${{ steps.infra.outputs.ecr_repo }}" \
            --ext-str EXECUTION_ROLE_ARN="${{ steps.infra.outputs.execution_role_arn }}" \
            --ext-str TASK_ROLE_ARN="${{ steps.infra.outputs.task_role_arn }}" \
            --ext-str SQS_QUEUE_URL="${{ steps.infra.outputs.sqs_queue_url }}" \
            ${{ env.SERVICE_NAME }}.jsonnet > ../task-definition.json
          cd ..
          
          echo "Generated task definition:"
          cat task-definition.json

      - name: Register Task Definition in LocalStack
        id: task-def
        run: |
          echo "Registering task definition in LocalStack..."
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "Registered task definition: $TASK_DEF_ARN"

      - name: Update ECS Service in LocalStack
        continue-on-error: true  # LocalStack may fail without Docker-in-Docker
        run: |
          CLUSTER="${{ env.PROJECT_NAME }}-prod"
          SERVICE="${{ env.PROJECT_NAME }}-prod-${{ env.SERVICE_NAME }}"
          
          echo "Updating ECS service..."
          echo "  Cluster: $CLUSTER"
          echo "  Service: $SERVICE"
          echo "  Task Definition: ${{ steps.task-def.outputs.task_def_arn }}"
          
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "${{ steps.task-def.outputs.task_def_arn }}" \
            --force-new-deployment \
            || echo "Update service failed (expected in mock mode without Docker)"
          
          echo "âœ… Service update command completed"

      - name: Verify Deployment
        continue-on-error: true
        run: |
          CLUSTER="${{ env.PROJECT_NAME }}-prod"
          SERVICE="${{ env.PROJECT_NAME }}-prod-${{ env.SERVICE_NAME }}"
          
          echo "Verifying deployment..."
          aws ecs describe-services \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query 'services[0].{status:status,runningCount:runningCount,desiredCount:desiredCount,taskDefinition:taskDefinition}' \
            || echo "Verify deployment failed (expected in mock mode, not supporting Docker in Docker)"

      - name: Production summary
        run: |
          echo "## ðŸŸ¢ Production Deployed - ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Task Definition | \`${{ steps.task-def.outputs.task_def_arn }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ needs.build.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Approved by | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | LocalStack (prod) |" >> $GITHUB_STEP_SUMMARY
